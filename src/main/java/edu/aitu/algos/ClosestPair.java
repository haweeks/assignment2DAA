package edu.aitu.algos; import java.util.*; public final class ClosestPair{ public static record Point(double x,double y){} private ClosestPair(){} public static double solve(Point[] pts){ if(pts==null||pts.length<2) return Double.POSITIVE_INFINITY; Point[] byX=pts.clone(); Arrays.sort(byX,Comparator.comparingDouble(Point::x)); Point[] byY=byX.clone(); return dnc(byX,byY,0,byX.length);} private static double dnc(Point[] byX,Point[] byY,int l,int r){ int n=r-l; if(n<=3) return brute(byX,l,r); int m=(l+r)>>>1; double midX=byX[m].x(); Point[] leftY=new Point[m-l]; Point[] rightY=new Point[r-m]; int li=0,ri=0; for(Point p:byY){ if(p.x()<midX||(p.x()==midX&&inRange(byX,l,m,p))){ if(li<leftY.length) leftY[li++]=p; } else { if(ri<rightY.length) rightY[ri++]=p; } } double dl=dnc(byX,leftY,l,m); double dr=dnc(byX,rightY,m,r); double d=Math.min(dl,dr); Point[] strip=new Point[n]; int sz=0; for(Point p:byY) if(Math.abs(p.x()-midX)<d) strip[sz++]=p; for(int i=0;i<sz;i++){ for(int j=i+1;j<sz&&(strip[j].y()-strip[i].y())<d;j++){ d=Math.min(d,dist(strip[i],strip[j])); } } return d; } private static boolean inRange(Point[] a,int l,int r,Point p){ for(int i=l;i<r;i++) if(a[i]==p) return true; return false;} private static double brute(Point[] a,int l,int r){ double d=Double.POSITIVE_INFINITY; for(int i=l;i<r;i++) for(int j=i+1;j<r;j++) d=Math.min(d,dist(a[i],a[j])); return d;} private static double dist(Point a,Point b){ double dx=a.x()-b.x(), dy=a.y()-b.y(); return Math.hypot(dx,dy);} }